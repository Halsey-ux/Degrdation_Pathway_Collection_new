<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMILES æ ‘çŠ¶åˆ†å­å›¾</title>
  <link rel="preload" href="RDKit_minimal.wasm" as="fetch" type="application/wasm" crossorigin="anonymous">
  <style>
    :root {
      --panel-bg: #e0e0e0;
      --panel-border: #c4c4c4;
      --accent: #0f6ad2;
      --text: #333;
      --node-radius: 38px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Arial, sans-serif;
      background: #fefefe;
      color: var(--text);
      min-height: 100vh;
      width: 100vw;
      overflow-x: hidden;
    }
    .app-shell {
      width: 100%;
      margin: 0 auto;
      background: #fff;
      border-radius: 0;
      box-shadow: none;
      overflow: hidden;
    }
    header {
      background: linear-gradient(90deg, #4d83ff, #7bb7ff);
      color: #fff;
      border-bottom: 1px solid rgba(255, 255, 255, 0.35);
      padding: 18px 24px;
      font-size: 22px;
      font-weight: 600;
    }
    button {
      border: 1px solid #b0b0b0;
      background: #ededed;
      color: #444;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      min-width: 48px;
    }
    button:hover { background: #e0e0e0; }
    button:active { transform: translateY(1px); }
    .builder {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      padding: 20px 24px;
      background: #fff;
      border-bottom: 1px solid var(--panel-border);
    }
    .panel {
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 12px;
      background: #fbfbfb;
    }
    .panel h3 {
      margin: 0 0 8px;
      font-size: 16px;
      color: #222;
    }
    .input-row {
      display: flex;
      flex-direction: column;
      margin-bottom: 8px;
      gap: 4px;
    }
    .input-row label {
      font-size: 13px;
      color: #555;
    }
    .input-row input {
      padding: 6px 8px;
      border: 1px solid #cfcfcf;
      border-radius: 4px;
      font-size: 13px;
    }
    .builder button {
      width: 100%;
      margin-top: 6px;
    }
    .hint {
      font-size: 12px;
      color: #777;
      margin: 0 0 6px;
    }
    .current-parent {
      font-size: 13px;
      margin-bottom: 6px;
      color: #222;
    }
    .current-parent span {
      font-weight: 600;
      color: var(--accent);
    }
    .status {
      padding: 10px 24px;
      border-bottom: 1px solid var(--panel-border);
      background: #fffdea;
      color: #8a6d1d;
      font-size: 14px;
    }
    .status.ready {
      background: #f0fff3;
      color: #1d7f3c;
    }
    .instructions {
      padding: 12px 24px 16px;
      font-size: 13px;
      color: #4a4a4a;
      border-bottom: 1px solid var(--panel-border);
      background: #fafafa;
    }
    .instructions .actions {
      margin-top: 8px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .instructions .actions button {
      min-width: 140px;
    }
    .canvas-frame {
      margin: 0 24px 24px;
      border: 1px solid #d7dce5;
      border-radius: 12px;
      background: #fdfdff;
      box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.06);
    }
    #canvas {
      width: 100%;
      height: calc(100vh - 320px);
      min-height: 420px;
      display: block;
    }
    svg text {
      font-family: "Segoe UI", Arial, sans-serif;
      font-size: 12px;
      fill: #444;
      pointer-events: none;
    }
    .link {
      fill: none;
      stroke: #c7c7c7;
      stroke-width: 1.2px;
    }
    .node circle {
      fill: #ededed;
      stroke: #d0d0d0;
      stroke-width: 1px;
    }
    .node {
      cursor: pointer;
    }
    .node.selected circle {
      stroke: var(--accent);
      stroke-width: 2px;
    }
    .node.duplicate circle {
      stroke: #d9534f;
      stroke-width: 3px;
    }
    #toast {
      position: fixed;
      top: 18px;
      right: 18px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.75);
      color: white;
      border-radius: 4px;
      font-size: 13px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 10;
    }
    #toast.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="app-shell">
  <header>Degradation Pathway</header>

  <section class="builder">
    <div class="panel">
      <h3>æ¯åˆ†å­</h3>
      <div class="input-row">
        <label for="rootName">åç§°ï¼ˆå¯é€‰ï¼‰</label>
        <input id="rootName" placeholder="ä¾‹å¦‚ï¼šBenzenesulfonyl chloride">
      </div>
      <div class="input-row">
        <label for="rootSmiles">SMILES</label>
        <input id="rootSmiles" placeholder="è¾“å…¥æ¯åˆ†å­çš„ SMILES">
      </div>
      <button id="setRootBtn">è®¾ç½®æ¯åˆ†å­</button>
    </div>
    <div class="panel">
      <h3>å­åˆ†å­</h3>
      <p class="hint">ç‚¹å‡»ä¸‹æ–¹ä»»æ„èŠ‚ç‚¹ï¼Œå³å¯æŠŠè¯¥èŠ‚ç‚¹è®¾ç½®ä¸ºå½“å‰æ¯åˆ†å­ã€‚</p>
      <div class="current-parent">å½“å‰æ¯åˆ†å­ï¼š<span id="selectedLabel">å°šæœªé€‰æ‹©</span></div>
      <div class="input-row">
        <label for="childName">åç§°ï¼ˆå¯é€‰ï¼‰</label>
        <input id="childName" placeholder="ä¾‹å¦‚ï¼šHydroquinone">
      </div>
      <div class="input-row">
        <label for="childSmiles">å­ SMILES</label>
        <input id="childSmiles" placeholder="è¾“å…¥è¦è¿æ¥çš„å­åˆ†å­ SMILES">
      </div>
      <button id="addChildBtn">æ·»åŠ å­åˆ†å­</button>
    </div>
  </section>

  <div id="status" class="status">æ­£åœ¨åŠ è½½ RDKit å†…æ ¸ï¼Œè¯·ç¨å€™â€¦</div>
  <div class="instructions">
    â‘  è¾“å…¥æ¯åˆ†å­çš„ SMILES å¹¶ç‚¹å‡»â€œè®¾ç½®æ¯åˆ†å­â€ï¼Œä¸‹æ–¹åŒºåŸŸä¼šç«‹å³ç”Ÿæˆç»“æ„å›¾ã€‚â‘¡ ç‚¹å‡»ä»»æ„èŠ‚ç‚¹å¯æŠŠå®ƒè®¾ä¸ºå½“å‰æ¯åˆ†å­ï¼Œå†è¾“å…¥å­ SMILES æ·»åŠ å­èŠ‚ç‚¹ã€‚â‘¢ é¼ æ ‡æ»šè½®å¯ç¼©æ”¾ï¼Œæ‹–åŠ¨ç©ºç™½åŒºåŸŸå¯å¹³ç§»ï¼Œä¿æŒæ ‘çŠ¶å›¾æ¸…æ™°ï¼›æ¯æ¬¡æ›´æ–°éƒ½ä¼šè‡ªåŠ¨å±…ä¸­ã€‚
    <div class="actions">
      <button id="undoBtn" title="æ’¤å›ä¸Šä¸€æ­¥">â†º æ’¤å›</button>
      <button id="redoBtn" title="æ¢å¤">â†» æ¢å¤</button>
      <button id="deleteNodeBtn" title="åˆ é™¤å½“å‰é€‰ä¸­çš„æ¯åˆ†å­åŠå…¶æ‰€æœ‰å­åˆ†å­">ğŸ—‘ åˆ é™¤å½“å‰åˆ†æ”¯</button>
      <button id="checkDuplicatesBtn" title="æŸ¥æ‰¾é‡å¤çš„ SMILES å¹¶ç”¨çº¢è‰²é«˜äº®">ğŸ” æŸ¥é‡</button>
      <button id="exportBtn">å¯¼å‡ºå½“å‰ SMILES (CSV)</button>
      <button id="exportTreeBtn">ä¿å­˜ååº”è·¯å¾„</button>
      <button id="importTreeBtn">è¯»å–ååº”è·¯å¾„</button>
      <input type="file" id="importFileInput" accept=".csv" style="display:none">
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite"></div>
  <div class="canvas-frame">
    <svg id="canvas"></svg>
  </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script>
    const RDKIT_CDN_BASE = "https://unpkg.com/rdkit-js@2023.9.5";
    const RDKIT_CDN_JS = `${RDKIT_CDN_BASE}/RDKit_minimal.js`;
    const RDKIT_CDN_WASM = `${RDKIT_CDN_BASE}/RDKit_minimal.wasm`;
    const RDKIT_LOCAL_JS = "rdkit_minimal.js";
    const RDKIT_LOCAL_WASM = "RDKit_minimal.wasm";

    let rdkitInitPromise = null;

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = src;
        script.async = true;
        script.onload = () => resolve(src);
        script.onerror = () => reject(new Error(`åŠ è½½è„šæœ¬å¤±è´¥ï¼š${src}`));
        document.head.appendChild(script);
      });
    }

    async function fetchWasm(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`æ‹‰å– wasm å¤±è´¥ï¼š${response.status}`);
      }
      const buffer = await response.arrayBuffer();
      return new Uint8Array(buffer);
    }

    function initRdkitModuleWithFallback() {
      if (!rdkitInitPromise) {
        rdkitInitPromise = loadScript(RDKIT_LOCAL_JS)
          .catch(err => {
            console.warn("CDN ç‰ˆ RDKit_minimal.js åŠ è½½å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°æ–‡ä»¶ã€‚", err);
            return loadScript(RDKIT_CDN_JS);
          })
          .then(() => fetchWasm(RDKIT_LOCAL_WASM)
            .catch(err => {
              console.warn("CDN wasm åŠ è½½å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ° wasmã€‚", err);
              return fetchWasm(RDKIT_CDN_WASM).catch(wasmErr => {
                console.warn("æœ¬åœ° wasm ä¹ŸåŠ è½½å¤±è´¥ï¼Œå°†ç”± Emscripten è‡ªè¡Œè·å–ã€‚", wasmErr);
                return null;
              });
            }))
          .then(wasmBinary => {
            if (typeof initRDKitModule !== "function") {
              throw new Error("initRDKitModule æœªå®šä¹‰ï¼ŒRDKit è„šæœ¬åŠ è½½å¤±è´¥ã€‚");
            }
            const moduleConfig = {
              locateFile: (file) => {
                if (file.endsWith(".wasm")) {
                  return wasmBinary ? RDKIT_LOCAL_WASM : RDKIT_CDN_WASM;
                }
                return file;
              }
            };
            if (wasmBinary) {
              moduleConfig.wasmBinary = wasmBinary;
            }
            return initRDKitModule(moduleConfig);
          });
      }
      return rdkitInitPromise;
    }

    const NODE_VERTICAL_SPACING = 180;
    const toastEl = document.getElementById("toast");
    const rootNameInput = document.getElementById("rootName");
    const rootSmilesInput = document.getElementById("rootSmiles");
    const childNameInput = document.getElementById("childName");
    const childSmilesInput = document.getElementById("childSmiles");
    const setRootBtn = document.getElementById("setRootBtn");
    const addChildBtn = document.getElementById("addChildBtn");
    const selectedLabel = document.getElementById("selectedLabel");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const deleteNodeBtn = document.getElementById("deleteNodeBtn");
    const checkDuplicatesBtn = document.getElementById("checkDuplicatesBtn");
    const exportBtn = document.getElementById("exportBtn");
    const exportTreeBtn = document.getElementById("exportTreeBtn");
    const importTreeBtn = document.getElementById("importTreeBtn");
    const importFileInput = document.getElementById("importFileInput");
    const statusEl = document.getElementById("status");
    const svg = d3.select("#canvas");
    svg.style("display", "block");
    const g = svg.append("g").attr("class", "viewport");
    const circleRadius = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--node-radius"), 10);
    const imageScale = 0.9;

    let zoom = null;
    let RDKit = null;
    let isRdkitReady = false;
    let currentTree = null;
    let selectedNodeId = null;
    let idCounter = 0;
    let toastTimer = null;
    let pendingTree = null;
    let duplicateNodeIds = new Set();
    const historyStack = [];
    const redoStack = [];

    commitState(null);

    initRdkitModuleWithFallback()
      .then(instance => {
        RDKit = instance;
        isRdkitReady = true;
        updateStatus("RDKit å·²å°±ç»ªï¼Œå¯ç›´æ¥æ„å»ºæ ‘çŠ¶å›¾ã€‚", true);
        setupZoom();
        if (pendingTree) {
          drawTree(pendingTree);
          pendingTree = null;
        }
      })
      .catch(err => {
        console.error("RDKit åŠ è½½å¤±è´¥: ", err);
        updateStatus("RDKit åŠ è½½å¤±è´¥ï¼š" + err, false);
        showToast("RDKit åŠ è½½å¤±è´¥ï¼š" + err, 4000);
      });

    function updateStatus(text, ready = false) {
      statusEl.textContent = text;
      statusEl.classList.toggle("ready", ready);
    }

    function showToast(text, duration = 2500) {
      if (!text) {
        toastEl.classList.remove("visible");
        toastEl.textContent = "";
        return;
      }
      toastEl.textContent = text;
      toastEl.classList.add("visible");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        toastEl.classList.remove("visible");
      }, duration);
    }

    function nextId() {
      return `node-${idCounter++}`;
    }

    function assignIds(node) {
      if (!node) return;
      if (!node.id) node.id = nextId();
      if (node.children) {
        node.children.forEach(assignIds);
      }
    }

    function cloneWithoutSvg(node) {
      if (!node) return null;
      const { svg, ...rest } = node;
      if (rest.children) {
        rest.children = rest.children.map(cloneWithoutSvg);
      }
      return rest;
    }

    function findNode(node, id) {
      if (!node) return null;
      if (node.id === id) return node;
      if (!node.children) return null;
      for (const child of node.children) {
        const found = findNode(child, id);
        if (found) return found;
      }
      return null;
    }

    function findParent(node, childId) {
      if (!node || !node.children) return null;
      for (const child of node.children) {
        if (child.id === childId) {
          return node;
        }
        const maybe = findParent(child, childId);
        if (maybe) return maybe;
      }
      return null;
    }

    function updateSelectedLabel() {
      const selected = findNode(currentTree, selectedNodeId);
      selectedLabel.textContent = selected ? (selected.name || selected.smiles) : "å°šæœªé€‰æ‹©";
    }

    function setupZoom() {
      zoom = d3.zoom().scaleExtent([0.35, 3]).on("zoom", event => {
        g.attr("transform", event.transform);
      });
      svg.call(zoom);
      svg.on("dblclick.zoom", null);
    }

    function queueRender(tree, fromUserAction = false) {
      if (!tree) {
        clearGraph();
        updateSelectedLabel();
        return;
      }
      if (!RDKit) {
        pendingTree = tree;
        if (fromUserAction) {
          updateStatus("RDKit æ­£åœ¨åŠ è½½ï¼Œå®Œæˆåä¼šç«‹åˆ»ç»˜åˆ¶å½“å‰ç»“æ„ã€‚", false);
          showToast("RDKit æ­£åœ¨åŠ è½½ï¼Œè¯·ç¨å€™â€¦", 2000);
        }
        return;
      }
      updateStatus("RDKit å·²å°±ç»ªï¼Œå¯ç»§ç»­æ·»åŠ èŠ‚ç‚¹ã€‚", true);
      drawTree(tree);
    }

    async function drawTree(tree) {
      if (!tree) return;
      try {
        const prepared = await attachSvgs(tree);
        const root = d3.hierarchy(prepared);
        const containerWidth = svg.node().parentNode.clientWidth;
        const containerHeight = svg.node().parentNode.clientHeight;
        svg.attr("width", containerWidth).attr("height", containerHeight);

        const treeLayout = d3.tree().nodeSize([160, NODE_VERTICAL_SPACING]);
        treeLayout(root);

        const links = g.selectAll(".link").data(root.links(), d => d.target.data.id);
        links.enter()
          .append("path")
          .attr("class", "link")
          .attr("d", d => drawLink(d))
          .merge(links)
          .transition().duration(200)
          .attr("d", d => drawLink(d));
        links.exit().remove();

        const nodes = g.selectAll(".node").data(root.descendants(), d => d.data.id);
        const nodeEnter = nodes.enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", d => `translate(${d.x},${d.y})`);

        nodeEnter.append("clipPath")
          .attr("id", d => `clip-${d.data.id}`)
          .append("circle")
          .attr("r", circleRadius);

        nodeEnter.append("circle").attr("r", circleRadius);

        nodeEnter.append("image")
          .attr("x", -circleRadius * imageScale)
          .attr("y", -circleRadius * imageScale)
          .attr("width", circleRadius * 2 * imageScale)
          .attr("height", circleRadius * 2 * imageScale)
          .attr("clip-path", d => `url(#clip-${d.data.id})`);

        nodeEnter.append("text")
        .attr("dy", circleRadius + 16)
          .attr("text-anchor", "middle");

        const nodeUpdate = nodeEnter.merge(nodes);
        nodeUpdate
          .attr("transform", d => `translate(${d.x},${d.y})`)
          .on("click", (event, d) => {
            event.stopPropagation();
            selectNode(d.data.id);
          })
          .classed("selected", d => d.data.id === selectedNodeId);

        nodeUpdate.select("image").attr("href", d => d.data.svg);
        nodeUpdate.select("text").text(d => d.data.name || d.data.smiles);
        nodes.exit().remove();

      updateSelectedStyles();
      centerGraph();
      } catch (err) {
        console.error(err);
        showToast("æ¸²æŸ“å¤±è´¥ï¼š" + err.message, 3500);
      }
    }

    function updateSelectedStyles() {
      g.selectAll(".node").classed("selected", d => d.data.id === selectedNodeId);
      g.selectAll(".node").classed("duplicate", d => duplicateNodeIds.has(d.data.id));
    }

    function clearDuplicateHighlights() {
      duplicateNodeIds.clear();
      g.selectAll(".node").classed("duplicate", false);
    }

    function commitState(tree) {
      historyStack.push(JSON.stringify(tree || null));
      if (historyStack.length > 40) {
        historyStack.shift();
      }
      redoStack.length = 0;
    }

    function undoLast() {
      if (historyStack.length <= 1) {
        showToast("æ²¡æœ‰å¯æ’¤å›çš„æ“ä½œã€‚");
        return;
      }
      const currentState = historyStack.pop();
      redoStack.push(currentState);
      const previousState = historyStack[historyStack.length - 1];
      applyState(previousState);
      showToast("å·²æ’¤å›ä¸Šä¸€æ­¥ã€‚");
    }

    function redoLast() {
      if (!redoStack.length) {
        showToast("æ²¡æœ‰å¯æ¢å¤çš„æ“ä½œã€‚");
        return;
      }
      const state = redoStack.pop();
      historyStack.push(state);
      applyState(state);
      showToast("å·²æ¢å¤æ“ä½œã€‚");
    }

    function applyState(state) {
      try {
        currentTree = state ? JSON.parse(state) : null;
        selectedNodeId = currentTree ? currentTree.id : null;
        clearDuplicateHighlights();
        updateSelectedLabel();
        queueRender(currentTree, true);
        if (currentTree) {
          centerGraph();
        } else {
          clearGraph();
        }
      } catch (err) {
        showToast("çŠ¶æ€æ¢å¤å¤±è´¥ï¼š" + err.message, 3500);
      }
    }

    function clearGraph() {
      g.selectAll(".node").remove();
      g.selectAll(".link").remove();
    }

    function centerGraph() {
      if (!zoom || !g.node()) return;
      const width = svg.node().clientWidth || window.innerWidth;
      const height = svg.node().clientHeight || (window.innerHeight - 200);
      const box = g.node().getBBox();
      if (!box || !isFinite(box.width) || box.width === 0) return;
      const scale = Math.min(1.6, Math.max(0.3, Math.min(width / (box.width + 120), height / (box.height + 120))));
      const tx = (width - (box.x + box.width) * scale) / 2;
      const ty = Math.max(20, (height - (box.y + box.height) * scale) / 3);
      svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
    }

    function drawLink(link) {
      const source = { ...link.source };
      const target = { ...link.target };
      const angle = Math.atan2(target.y - source.y, target.x - source.x);
      const offsetX = Math.cos(angle) * circleRadius;
      const offsetY = Math.sin(angle) * circleRadius;

      source.x += offsetX;
      source.y += offsetY;
      target.x -= offsetX;
      target.y -= offsetY;

      return d3.linkVertical().x(d => d.x).y(d => d.y)({ source, target });
    }

    async function attachSvgs(node) {
      async function walk(n) {
        if (!n || !n.smiles) throw new Error("èŠ‚ç‚¹ç¼ºå°‘ SMILESã€‚");
        if (!n.id) n.id = nextId();
        const mol = RDKit.get_mol(n.smiles);
        if (!mol) throw new Error("æ— æ³•è§£æï¼š" + n.smiles);
        const svg = mol.get_svg();
        mol.delete();
        const encoded = encodeURIComponent(svg);
        const children = n.children ? await Promise.all(n.children.map(child => walk(child))) : [];
        return { ...n, svg: `data:image/svg+xml;charset=utf-8,${encoded}`, children };
      }
      return walk(JSON.parse(JSON.stringify(node)));
    }

    function selectNode(id) {
      const node = findNode(currentTree, id);
      if (!node) return;
      selectedNodeId = id;
      updateSelectedLabel();
      updateSelectedStyles();
      showToast(`å·²é€‰æ‹©ï¼š${node.name || node.smiles}`);
    }

    function deleteSelectedSubtree() {
      if (!currentTree) {
        showToast("è¯·å…ˆè®¾ç½®æ¯åˆ†å­ã€‚");
        return;
      }
      if (!selectedNodeId) {
        showToast("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„èŠ‚ç‚¹ã€‚");
        return;
      }
      const target = findNode(currentTree, selectedNodeId);
      if (!target) {
        showToast("æ‰¾ä¸åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹ã€‚");
        return;
      }
      const label = target.name || target.smiles || "èŠ‚ç‚¹";
      if (target.id === currentTree.id) {
        currentTree = null;
        selectedNodeId = null;
      } else {
        const parent = findParent(currentTree, selectedNodeId);
        if (!parent) {
          showToast("æ— æ³•æ‰¾åˆ°èŠ‚ç‚¹çš„æ¯åˆ†å­ã€‚");
          return;
        }
        parent.children = (parent.children || []).filter(child => child.id !== selectedNodeId);
        selectedNodeId = parent.id;
      }
      commitState(currentTree);
      clearDuplicateHighlights();
      updateSelectedLabel();
      queueRender(currentTree, true);
      if (currentTree) {
        centerGraph();
      } else {
        clearGraph();
      }
      showToast(`å·²åˆ é™¤ ${label}`);
    }

    setRootBtn.addEventListener("click", () => {
      const smiles = rootSmilesInput.value.trim();
      if (!smiles) {
        showToast("è¯·å…ˆè¾“å…¥æ¯åˆ†å­çš„ SMILESã€‚");
        return;
      }
      const name = rootNameInput.value.trim();
      currentTree = { smiles, children: [] };
      if (name) currentTree.name = name;
      assignIds(currentTree);
      selectedNodeId = currentTree.id;
      clearDuplicateHighlights();
      updateSelectedLabel();
      queueRender(currentTree, true);
      centerGraph();
      commitState(currentTree);
      showToast(isRdkitReady ? "å·²è®¾ç½®æ–°çš„æ¯åˆ†å­ã€‚" : "å·²è®¾ç½®æ¯åˆ†å­ï¼Œç­‰å¾… RDKit æ¸²æŸ“â€¦");
    });

    addChildBtn.addEventListener("click", () => {
      if (!currentTree) {
        showToast("è¯·å…ˆè®¾ç½®æ¯åˆ†å­ã€‚");
        return;
      }
      const parent = findNode(currentTree, selectedNodeId);
      if (!parent) {
        showToast("è¯·å…ˆç‚¹å‡»å›¾ä¸­çš„æŸä¸ªèŠ‚ç‚¹ã€‚");
        return;
      }
      const smiles = childSmilesInput.value.trim();
      if (!smiles) {
        showToast("è¯·å¡«å†™å­åˆ†å­çš„ SMILESã€‚");
        return;
      }
      const name = childNameInput.value.trim();
      const newNode = { smiles, children: [] };
      if (name) newNode.name = name;
      assignIds(newNode);
      parent.children = parent.children || [];
      parent.children.push(newNode);
      childNameInput.value = "";
      childSmilesInput.value = "";
      clearDuplicateHighlights();
      queueRender(currentTree, true);
      centerGraph();
      commitState(currentTree);
      showToast(isRdkitReady ? `å·²ä¸º ${parent.name || parent.smiles} æ·»åŠ å­èŠ‚ç‚¹ã€‚` : "å­èŠ‚ç‚¹å·²åŠ å…¥ï¼Œç­‰å¾… RDKit æ¸²æŸ“â€¦");
    });

    exportBtn.addEventListener("click", async () => {
      if (!currentTree) {
        showToast("è¯·å…ˆè®¾ç½®æ¯åˆ†å­ä¹‹åå†å¯¼å‡ºã€‚");
        return;
      }
      try {
        const smilesList = [];
        collectSmiles(currentTree, smilesList);
        const csv = smilesList.join("\r\n");
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const fileName = `smiles_${new Date().toISOString().replace(/[:.]/g, "-")}.csv`;
        const savedWithPicker = await saveWithPicker(blob, fileName);
        if (!savedWithPicker) {
    triggerDownload(blob, fileName);
      }
      showToast("å·²å¯¼å‡ºå½“å‰ SMILESã€‚");
    } catch (err) {
      console.error(err);
      showToast("å¯¼å‡ºå¤±è´¥ï¼š" + err.message, 3500);
    }
    });

    exportTreeBtn.addEventListener("click", () => {
      handleExportTree();
    });

    importTreeBtn.addEventListener("click", () => {
      importFileInput.value = "";
      importFileInput.click();
    });

    importFileInput.addEventListener("change", event => {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const text = e.target.result;
          const tree = parseTreeCsv(text);
          currentTree = tree;
          selectedNodeId = currentTree ? currentTree.id : null;
          updateSelectedLabel();
          commitState(currentTree);
          clearDuplicateHighlights();
          queueRender(currentTree, true);
          if (currentTree) {
            centerGraph();
          }
          showToast("å·²è½½å…¥ä¿å­˜çš„ååº”è·¯å¾„ã€‚");
        } catch (err) {
          console.error(err);
          showToast("å¯¼å…¥å¤±è´¥ï¼š" + err.message, 3500);
        }
      };
      reader.onerror = () => {
        showToast("è¯»å–æ–‡ä»¶å¤±è´¥ã€‚", 3500);
      };
      reader.readAsText(file, "utf-8");
    });

    deleteNodeBtn.addEventListener("click", () => {
      deleteSelectedSubtree();
    });

    checkDuplicatesBtn.addEventListener("click", () => {
      checkDuplicateSmiles();
    });

    undoBtn.addEventListener("click", () => {
      undoLast();
    });

    redoBtn.addEventListener("click", () => {
      redoLast();
    });

    window.addEventListener("keydown", event => {
      if (event.altKey && !event.shiftKey && !event.ctrlKey) {
        if (event.key.toLowerCase() === "z") {
          event.preventDefault();
          undoLast();
        } else if (event.key.toLowerCase() === "y") {
          event.preventDefault();
          redoLast();
        }
      }
    });

    function collectSmiles(node, acc) {
      if (!node) return;
      if (node.smiles) {
        acc.push(node.smiles);
      }
      if (node.children) {
        node.children.forEach(child => collectSmiles(child, acc));
      }
    }

    function collectNodesBySmiles(node, map) {
      if (!node) return;
      const key = (node.smiles || "").trim();
      if (key) {
        if (!map.has(key)) {
          map.set(key, []);
        }
        map.get(key).push(node.id);
      }
      if (node.children) {
        node.children.forEach(child => collectNodesBySmiles(child, map));
      }
    }

    function checkDuplicateSmiles() {
      if (!currentTree) {
        showToast("è¯·å…ˆè®¾ç½®æ¯åˆ†å­æˆ–å¯¼å…¥ååº”è·¯å¾„ã€‚");
        return;
      }
      assignIds(currentTree);
      const map = new Map();
      collectNodesBySmiles(currentTree, map);
      duplicateNodeIds = new Set();
      let groups = 0;
      map.forEach(ids => {
        if (ids.length > 1) {
          groups += 1;
          ids.forEach(id => duplicateNodeIds.add(id));
        }
      });
      updateSelectedStyles();
      if (duplicateNodeIds.size) {
        showToast(`å‘ç° ${groups} ç»„é‡å¤ SMILESï¼Œå·²ç”¨çº¢è‰²é«˜äº®ã€‚`);
      } else {
        showToast("æœªå‘ç°é‡å¤çš„ SMILESã€‚");
      }
    }

    async function handleExportTree() {
      if (!currentTree) {
        showToast("è¯·å…ˆæ„å»ºä¸€æ¡ååº”è·¯å¾„å†ä¿å­˜ã€‚");
        return;
      }
      try {
        assignIds(currentTree);
        const rows = [];
        collectTreeRows(currentTree, null, rows);
        const csv = buildTreeCsv(rows);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const fileName = `pathway_${new Date().toISOString().replace(/[:.]/g, "-")}.csv`;
        const saved = await saveWithPicker(blob, fileName);
        if (!saved) {
          triggerDownload(blob, fileName);
        }
        showToast("å·²ä¿å­˜ååº”è·¯å¾„ã€‚");
      } catch (err) {
        console.error(err);
        showToast("ä¿å­˜å¤±è´¥ï¼š" + err.message, 3500);
      }
    }

    function collectTreeRows(node, parentId, acc) {
      if (!node) return;
      acc.push({
        id: node.id || "",
        parentId: parentId || "",
        name: node.name || "",
        smiles: node.smiles || ""
      });
      if (node.children) {
        node.children.forEach(child => collectTreeRows(child, node.id, acc));
      }
    }

    function buildTreeCsv(rows) {
      const header = ["id", "parentId", "name", "smiles"];
      const escape = value => `"${String(value || "").replace(/"/g, '""')}"`;
      const lines = [header.join(",")];
      rows.forEach(row => {
        lines.push(
          [row.id, row.parentId, row.name, row.smiles].map(escape).join(",")
        );
      });
      return lines.join("\r\n");
    }

    function parseTreeCsv(text) {
      const lines = text.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
      if (lines.length < 2) {
        throw new Error("æ–‡ä»¶å†…å®¹ä¸ºç©ºã€‚");
      }
      const header = parseCsvLine(lines[0]).map(h => h.trim().toLowerCase());
      const idIdx = header.indexOf("id");
      const parentIdx = header.indexOf("parentid");
      const nameIdx = header.indexOf("name");
      const smilesIdx = header.indexOf("smiles");
      if (idIdx === -1 || parentIdx === -1 || nameIdx === -1 || smilesIdx === -1) {
        throw new Error("CSV éœ€åŒ…å« id,parentId,name,smiles åˆ—ã€‚");
      }

      const tempNodes = new Map();
      lines.slice(1).forEach((line, index) => {
        if (!line) return;
        const cols = parseCsvLine(line);
        const smiles = cols[smilesIdx]?.trim();
        if (!smiles) {
          throw new Error(`ç¬¬ ${index + 2} è¡Œç¼ºå°‘ SMILESã€‚`);
        }
        const tempId = cols[idIdx]?.trim() || `row-${index}`;
        if (tempNodes.has(tempId)) {
          throw new Error(`CSV ä¸­å­˜åœ¨é‡å¤ idï¼š${tempId}`);
        }
        const node = {
          name: cols[nameIdx]?.trim() || "",
          smiles,
          children: [],
          _parent: cols[parentIdx]?.trim() || ""
        };
        tempNodes.set(tempId, node);
      });

      let root = null;
      tempNodes.forEach((node, key) => {
        const parentKey = node._parent;
        if (parentKey && tempNodes.has(parentKey)) {
          tempNodes.get(parentKey).children.push(node);
        } else {
          if (root) {
            throw new Error("å­˜åœ¨å¤šä¸ªæ ¹èŠ‚ç‚¹ï¼Œè¯·æ£€æŸ¥ parentId åˆ—ã€‚");
          }
          root = node;
        }
        delete node._parent;
      });

      if (!root) {
        throw new Error("æœªæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œè¯·æ£€æŸ¥ parentId åˆ—ã€‚");
      }

      idCounter = 0;
      assignIds(root);
      return root;
    }

    function parseCsvLine(line) {
      const result = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (inQuotes) {
          if (char === '"') {
            if (line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
        } else {
          if (char === '"') {
            inQuotes = true;
          } else if (char === ",") {
            result.push(current);
            current = "";
          } else {
            current += char;
          }
        }
      }
      result.push(current);
      return result;
    }

    async function saveWithPicker(blob, suggestedName) {
      if (!window.showSaveFilePicker) return false;
      const handle = await window.showSaveFilePicker({
        suggestedName,
        types: [
          {
            description: "CSV æ–‡ä»¶",
            accept: { "text/csv": [".csv"] }
          }
        ]
      });
      const writable = await handle.createWritable();
      await writable.write(blob);
      await writable.close();
      return true;
    }

    function triggerDownload(blob, fileName) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
